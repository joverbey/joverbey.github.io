#!/bin/bash
#
# generate-test.sh -- generate a test file for the x86 subset assembler from
#                     output generated by showinsn.bat or showall.bat
#
# Usage:
# First, in Windows:
#  showall.bat > test-insns.txt
# Next, in Linux:
#  cat test-insns.txt | ./generate-test.sh | tee test-x86asm.c
#  cp ../x86-assembler/x86asm.{c,h} .
#  gcc -o test-x86asm test-x86asm.c x86asm.c
#  ./test-x86asm
#

cat << EOF
// x86 Subset Assembler - Tests
//-----------------------------------------------------------------------------
// Copyright (C) 2017 Jeffrey L. Overbey.  Use of this source code is governed
// by a BSD-style license posted at http://blog.jeff.over.bz/license/

#include "x86asm.h"
#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

uint8_t buf[256];

static void print_array(const uint8_t *array, size_t len) {
    for (size_t i = 0; i < len; i++) {
        printf(" %02x", array[i]);
    }
    printf("\n");
}

static _Bool arrays_match(const uint8_t *array1, size_t len1,
                          const uint8_t *array2, size_t len2) {
    if (len1 != len2) {
        return false;
    }
    for (size_t i = 0; i < len1; i++) {
        if (array1[i] != array2[i]) {
            return false;
        }
    }
    return true;
}

/// After an instruction is encoded into \c buf, this function receives a
/// pointer \c ptr to the last byte beyond the end of the encoded instruction,
/// and ensures that the encoded instruction consists of exactly
/// \c num_bytes bytes matching the bytes in \c expected.
static void expect(size_t num_bytes,
                   const uint8_t *expected,
                   const uint8_t *ptr,
                   const char *description) {
    size_t buflen = ptr - buf;    // Number of bytes encoded
    if (!arrays_match(expected, num_bytes, buf, buflen)) {
        printf("***** ENCODINGS DO NOT MATCH *****\n");
        printf("Instruction: %s\n", description);
        printf("Expected:    "); print_array(expected, num_bytes);
        printf("Actual:      "); print_array(buf, buflen);
        exit(EXIT_FAILURE);
    }
}

#define EXPECT(expected_num_bytes, expected, call) {   \\
    expect(expected_num_bytes, expected, call, #call); \\
}

int main() {
EOF

# Each line of the input will have the following form:
#  00000000: B8 00 00 00 00     mov         eax,0
while read line; do
    # Extract the encoding and instructions from the input line
    encoding=`echo "$line" | cut -c 11-29 | sed -e 's/[[:space:]]*$//'`
    insn=`echo "$line" | cut -c 30- | sed -e 's/[[:space:]]*$//'`

    # Insert commas between values in the encoding and convert hex (EF -> 0xEF)
    # (so it can be used as an array literal in the generated C code)
    array=`echo "$encoding"   \
          | sed -e 's/ /, /g' \
          | sed -Ee 's/([0-9A-F]+)/0x\1/g'`

    # Determine how many values are in the encoding
    num_commas=`echo "$array" | tr -cd ',' | wc -c`
    num_bytes=`expr $num_commas + 1`

    # Split the instruction into the mnemonic and the operands
    mnemonic=`echo "$insn" | awk '{ print $1 }'`
    operands=`echo "$insn" | awk '{ $1=""; print $0 }' | sed -e 's/^ *//'`

    # Now translate the instruction into an x86asm.h function call

    # Change the operands to jump instructions from DUMPBIN's labels to
    # the byte offsets expected by our assembler, convert register names
    # to uppercase, and convert hex literals (0Fh -> 0x0F)
    operands_fixed=`echo "$operands"                     \
                        | sed -e 's/,/, /'               \
                        | sed -e 's/main/-2/'            \
                        | sed -e 's/00000002/0/'         \
                        | sed -e 's/00000007/5/'         \
                        | sed -e 's/0000000C/10/'        \
                        | sed -e 's/00000066/100/'       \
                        | sed -e 's/000000CD/200/'       \
                        | sed -e 's/000000CE/200/'       \
                        | sed -e 's/00000131/300/'       \
                        | sed -e 's/00000132/300/'       \
                        | tr "[:lower:]" "[:upper:]"     \
                        | sed -Ee 's/([0-9A-F]+)H/0x\1/g'`

    # The C function name is the same as the mnemonic unless we change it later
    func="$mnemonic"

    # Now, fix specific instructions
    case "$mnemonic" in
        mul|idiv)
            # Our mul, div, and idiv instructions disassemble with 2 operands
            # Eliminate the first operand
            operands_fixed=`echo "$operands_fixed" | sed -e 's/EAX, //'`
            ;;
        div)
            # For div, also change the C function name to "div_"
            operands_fixed=`echo "$operands_fixed" | sed -e 's/EAX, //'`
            func="div_"
            ;;
        ret)
            # The "ret 0" instruction disassembles as "ret"
            if [ "$operands_fixed" == "" ]; then
                    operands_fixed="0"
            fi
            ;;
        shl|sal|shr|sar|rol|ror)
            # Determine if the second operand is the CL register
            # If so, change the function name and remove the ",cl"
            if echo "$operands" | grep 'cl' > /dev/null 2>&1; then
                func="${mnemonic}_cl"
                operands_fixed=`echo "$operands_fixed" | sed -e 's/, CL//'`
            fi
            ;;
        mov)
            # Change the function name from mov to mov_immediate if appropriate
            # Determine if the *second* operand is an immediate value
            # If it is a register, it will contains the letter x, p, or i
            # (eax, ecx, ..., esp, ebp, esi, edi)
            echo "$operands" | cut -d ',' -f 2 | egrep 'x|p|i' >/dev/null 2>&1
            if [ $? == 1 ]; then
                func="${mnemonic}_immediate"
            fi
            # Change to mov_from_ptr if appropriate
            echo "$operands" | cut -d ',' -f 2 | grep 'dword ptr' >/dev/null 2>&1
            if [ $? == 0 ]; then
                func="${mnemonic}_from_ptr"
            fi
            # Change to mov_to_ptr if appropriate
            echo "$operands" | cut -d ',' -f 1 | grep 'dword ptr' >/dev/null 2>&1
            if [ $? == 0 ]; then
                func="${mnemonic}_to_ptr"
            fi
            # Fix operands for mov_to/from_ptr
            echo "$operands" | grep 'dword ptr' >/dev/null 2>&1
            if [ $? == 0 ]; then
                operands_fixed=`echo "$operands_fixed" | sed -e 's/DWORD PTR \[//'`
                operands_fixed=`echo "$operands_fixed" | sed -e 's/\]//'`
            fi
            ;;
    esac

    # Finally, write the C code to test this instruction
    if [ "$operands_fixed" == "" ]; then
        args="buf"
    else
        args="$operands_fixed, buf"
    fi
    echo "    EXPECT($num_bytes, ((uint8_t []) { $array }), $func($args));"
done

cat << EOF
    printf("All tests passed!\n");
    return EXIT_SUCCESS;
}
EOF

exit 0

# -----------------------------------------------------------------------------
# Copyright (C) 2017 Jeffrey L. Overbey.  Use of this source code is governed
# by a BSD-style license posted at http://blog.jeff.over.bz/license/
